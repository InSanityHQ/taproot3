<html><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta name="author" /><meta content="A note on Taproot, a connected notes system." name="description" /><title>Compilers</title><link href="/static/css/firn_base.css" rel="stylesheet" /><link href="/static/css/prism.css" rel="stylesheet" /><link href="/static/css/global.css" rel="stylesheet" /><link href="/static/css/admonition.css" rel="stylesheet" /><script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        'displayAlign': 'center',
        'displayIndent': '0em',
        'extensions': ['tex2jax.js'],
        'tex2jax': {
        'inlineMath': [ ['$','$'], ['\\(','\\)'] ],
        'processEscapes': true
        },
        'HTML-CSS': { scale: 100,
                        linebreaks: { automatic: 'false' },
                        webFont: 'TeX'
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: 'false' },
              font: 'TeX'},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: 'AMS'},
               MultLineWidth: '85%',
               TagSide: 'right',
               TagIndent: '.8em'
             }})</script></head><body><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js" type="text/javascript"></script><script crossorigin=="anonymous" src="https://kit.fontawesome.com/76c5ce8bda.js"></script><div class="headerline"><a class="wordmark" href="https://taproot3.sanity.gq/" style="border:0">TR3</a></div><main><article class="content rss"><div class="preamble"><h1 class="title">Compilers</h1></div><div class="metamble"></div><div class="notebody"><div><section><p><span>These are my notes on the book </span><em><span>Compilers: Principles, Techniques, and Tools</span></em><span>.</span></p></section><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="basic-structure"><span class="firn-headline-text"><span>Basic Structure</span></span></h1><section><p><span>A simple compiler goes through about seven stages, maintaining a symbol table to help with each step.</span></p><p><a href="#imagesstepspng"></a></p></section><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="lexical-analysis"><span class="firn-headline-text"><span>Lexical Analysis</span></span></h2><section><p><span>After being handed modified code from the preprocessor, the compiler begins the lexical analysis stage in which it parses the code for tokens (or </span><em><span>lexemes</span></em><span>) of form </span><code><token-type, value></code><span>.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="syntax-analysis"><span class="firn-headline-text"><span>Syntax Analysis</span></span></h2><section><p><span>The list of tokens are then passed to the syntax analyzer which is responsible for generating an intermediate form organized around the language's grammar. This is done with a </span><em><span>syntax tree</span></em><span>, a tree where each node is an operator and its children are its arguments. This intermediate representation helps with later stages of the process.</span></p><p><span>Example: See chart at top for how the earlier example translates to a syntax tree.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="semantic-analysis"><span class="firn-headline-text"><span>Semantic Analysis</span></span></h2><section><p><span>Semantic analysis uses the syntax tree generated by the syntax analyzer to check that the code follows the language's grammar.</span></p><p><span>The semantic analyzer also collects type information and stores it within the syntax tree or symbol table. Type checking is also done at this stage and the semantic analyzer ensures that the types of operator arguments match. Languages (like C) tend to support </span><em><span>type coercions</span></em><span> where certain types are converted to allow operations to work. Were the semantic analyzer to notice that </span><code>position</code><span>, </span><code>initial</code><span>, and </span><code>rate</code><span> are all floating points, it is responsible for adding an extra node for the </span><code>inttofloat</code><span> function for conversion of the integer 60.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="intermediate-code-generation"><span class="firn-headline-text"><span>Intermediate Code Generation</span></span></h2><section><p><span>Most compilers generate abstract assembly-like code not specific to any architecture (but easily translatable to real assembly) to allow for high-level optimization in the next stage. This code is called </span><em><span>three-address code</span></em><span>, because it has at most three operands, and at most a single operator on the right side.</span></p><p><span>Example:</span></p><pre class="language-"><code class="language-">t1 = inttofloat(60)
t2 = id3 * t1
t3 = id2 + t2
id1 = t3
</code></pre></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="code-optimization"><span class="firn-headline-text"><span>Code Optimization</span></span></h2><section><p><span>High-level optimization is performed on the three-address code.</span></p><p><span>Example:</span></p><ul><li><p><code>inttofloat</code><span> can be run at compiled time and be replaced with its output, as 60 is an immediate value, not a variable.</span></p></li><li><p><code>t2</code><span> and </span><code>t3</code><span> calculations are not needed as they serves as intermediate calculations for the final </span><code>id1</code><span> calculation.</span></p></li></ul><pre class="language-"><code class="language-">t1 = id3 * 60.0
id1 = id2 + t1
</code></pre></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="code-generation"><span class="firn-headline-text"><span>Code Generation</span></span></h2><section><p><span>Machine-specific assembly code is generated from the optimized intermediate code. Tasks like register allocation are most important in this step.</span></p><p><span>Example:</span></p><pre class="language-"><code class="language-">LDF R2, id3
MULF R2, R2, #60.0
LDF R1, id2
ADDF R1, R1, R2
STF id1, R1
</code></pre></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="machine-dependent-code-optimization"><span class="firn-headline-text"><span>Machine-Dependent Code Optimization</span></span></h2><section><p><span>Machine-specific optimizations are performed upon the final assembly code. As the name implies, strategies for this vary quite a bit but usually rely on </span><a class="firn-internal" href="/corners/david/lowlevel">low-level</a><span> details.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="symbol-table-management"><span class="firn-headline-text"><span>Symbol-Table Management</span></span></h2><section><p><span>The symbol table is an important data-structure for recording the variable/function names used in the source code and their attributes. Said attributes can include name, type, scope, storage allocated for the variable, and for functions, the number of arguments and method of passing them.</span></p></section></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="simple-compiler-frontend"><span class="firn-headline-text"><span>Simple Compiler Frontend</span></span></h1><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="context-free-grammar"><span class="firn-headline-text"><span>Context-Free Grammar</span></span></h2><section><p><span>Grammars describe the syntactical constructs we use in code.</span></p><p><span>Example:
$stmt \rightarrow \textbf{if (} expr \textbf{) } stmt \textbf{ else } stmt$</span></p><p><span>This arrow (called a </span><em><span>production</span></em><span>) is a sort of definition, meaning that the statement can have that form.
The keywords like </span><strong><span>if</span></strong><span> and </span><strong><span>else</span></strong><span> are called </span><em><span>terminals</span></em><span>, while </span><em><span>expr</span></em><span> and </span><em><span>stmt</span></em><span> are </span><em><span>nonterminals</span></em><span>.</span></p><p><span>Grammars must have:</span></p><ul><li><p><span>A set of terminals</span></p></li><li><p><span>A set of nonterminals</span></p></li><li><p><span>A set of productions for nonterminals</span></p></li><li><p><span>A "start" nonterminal</span></p></li></ul><p><span>Example:
A grammar for processing simple one-digit arithmetic (like </span><code>9-5+2</code><span>) could be defined by the following productions (note that since digits must be separated by operators, it can be thought of a list of digits separated by operators):</span></p><p><span>$list \rightarrow list \textbf{ + } digit \text{ | } list \textbf{ - } digit \text{ | } digit$</span></p><p><span>$digit \rightarrow 0 \text{ | } 1 \text{ | } 2 \text{ | } 3 \text{ | } 4 \text{ | } 5 \text{ | } 6 \text{ | } 7 \text{ | } 8 \text{ | } 9$</span></p><p><span>The class of a string is determined by beginning with the start nonterminal and replacing each nonterminal with one of its productions.</span></p><p><span>Example: 
The string </span><code>9-5+2</code><span> is a $list$ because:</span></p><ul><li><p><code>9</code><span> is a $list$ by production $list \rightarrow digit$, as </span><code>9</code><span> is a $digit$.</span></p></li><li><p><code>9-5</code><span> is a $list$ by production $list \rightarrow list \textbf{ - } digit$, as </span><code>9</code><span> is a $list$ and </span><code>5</code><span> is a $digit$.</span></p></li><li><p><code>9-5+2</code><span> is a $list$ by production $list \rightarrow list \textbf{ + } digit$ , as </span><code>9-5</code><span> is a $list$ and </span><code>2</code><span> is a $digit$.</span></p></li></ul><p><span>Example:
The grammar for a function call would look something like this:</span></p><p><span>$call \rightarrow \textbf{id ( } params \textbf{ )}$</span></p><p><span>$params \rightarrow params \textbf{ , } param \text{ | } param$</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="parse-trees"><span class="firn-headline-text"><span>Parse Trees</span></span></h2><section><p><span>Parsing is the step where the compiler attempts to derive what nonterminal the string is from the start symbol of the grammar.</span></p><p><span>Parse trees represent how this derivation takes place. In a parse tree,</span></p><ul><li><p><span>The root is the start symbol</span></p></li><li><p><span>Interior nodes (those with children and parents) are nonterminals</span></p></li><li><p><span>Leaves (nodes with no children) are terminals</span></p></li><li><p><span>The children of an interior node must represent a production for that node.</span></p></li></ul><p><span>The leaves of a parse tree, from left to right, are called its </span><em><span>yield</span></em><span> which is the string derived from the root of the parse tree.</span></p></section><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="ambiguity"><span class="firn-headline-text"><span>Ambiguity</span></span></h3><section><p><span>Note that grammars can have more than one possible parse tree for a string. These are called ambigous grammars.</span></p><p><span>Example:
If the $digits$ nonterminal was combined with $list$ to create a more 
general $string$, the grammar would be ambigous.</span></p><p><a href="#imagesambigouspng"></a></p></section></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="operator-associativity"><span class="firn-headline-text"><span>Operator Associativity</span></span></h3><section><p><code>9+5+2</code><span> is the same as </span><code>(9+5)+2</code><span> and </span><code>9+(5+2)</code><span>, and therefore a decision must be made on which operation the </span><code>5</code><span> is a part of. Operations that priortize the </span><code>(9+5)+2</code><span> are called left-associative, whilst the opposite is known as right-associative. Most basic arithmetic operations are implemented as left-associative, but operators like exponentiation and assignment (in the case of C) are right-associative.</span></p><p><span>Example:
A grammar for C assignment would be something like</span></p><p><span>$right \rightarrow letter \textbf{ = } right \text{ | } letter$</span></p><p><span>$letter \rightarrow \textbf{a}\text{ | }\textbf{b}\text{ | }\ldots\text{ | }\textbf{z}$</span></p><p><a href="#imagesassociativepng"></a></p></section></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="operator-precedence"><span class="firn-headline-text"><span>Operator Precedence</span></span></h3><section><p><code>9+5*2</code><span> could be read as </span><code>(9+5)*2</code><span> or </span><code>9+(5*2)</code><span> and associativity does not resolve which one should be chose (as one is blatantly incorrect) so the concept of </span><em><span>operator precedence</span></em><span> is used instead, with operators of higher precedence like </span><code>*</code><span> claiming </span><code>5</code><span>.</span></p><p><span>Example:
A more complete set of productions can be used to represent our grammar for simple math now with the knowledge of operator precedence and associativity.</span></p><p><a href="#imagessimple-grammarpng"></a></p><p><span>The production rules for $expr$ ensure that $term$ will have precedence.</span></p></section></div></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="syntax-directed-translation"><span class="firn-headline-text"><span>Syntax-Directed Translation</span></span></h2></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="parsing"><span class="firn-headline-text"><span>Parsing</span></span></h2></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="simple-translation"><span class="firn-headline-text"><span>Simple Translation</span></span></h2></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="lexical-analysis"><span class="firn-headline-text"><span>Lexical Analysis</span></span></h2></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="symbol-tables"><span class="firn-headline-text"><span>Symbol Tables</span></span></h2></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="intermediate-code-generation"><span class="firn-headline-text"><span>Intermediate Code Generation</span></span></h2><section></section></div></div></div></div></article><div class="metapanel"><div class="metalabel">Contents</div><ol><li><a href="#basic-structure">Basic Structure</a><ol><li><a href="#lexical-analysis">Lexical Analysis</a></li><li><a href="#syntax-analysis">Syntax Analysis</a></li><li><a href="#semantic-analysis">Semantic Analysis</a></li><li><a href="#intermediate-code-generation">Intermediate Code Generation</a></li><li><a href="#code-optimization">Code Optimization</a></li><li><a href="#code-generation">Code Generation</a></li><li><a href="#machine-dependent-code-optimization">Machine-Dependent Code Optimization</a></li><li><a href="#symbol-table-management">Symbol-Table Management</a></li></ol></li><li><a href="#simple-compiler-frontend">Simple Compiler Frontend</a><ol><li><a href="#context-free-grammar">Context-Free Grammar</a></li><li><a href="#parse-trees">Parse Trees</a><ol><li><a href="#ambiguity">Ambiguity</a></li><li><a href="#operator-associativity">Operator Associativity</a></li><li><a href="#operator-precedence">Operator Precedence</a></li></ol></li><li><a href="#syntax-directed-translation">Syntax-Directed Translation</a></li><li><a href="#parsing">Parsing</a></li><li><a href="#simple-translation">Simple Translation</a></li><li><a href="#lexical-analysis">Lexical Analysis</a></li><li><a href="#symbol-tables">Symbol Tables</a></li><li><a href="#intermediate-code-generation">Intermediate Code Generation</a></li></ol></li></ol><div class="metalabel">Backlinks</div></div></main></body></html>