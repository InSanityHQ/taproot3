<html><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="David Freifeld" name="author" /><meta content="A note on Taproot, a connected notes system." name="description" /><title>User Input Validation</title><link href="/static/css/firn_base.css" rel="stylesheet" /><link href="/static/css/prism.css" rel="stylesheet" /><link href="/static/css/global.css" rel="stylesheet" /><link href="/static/css/admonition.css" rel="stylesheet" /><script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        'displayAlign': 'center',
        'displayIndent': '0em',
        'extensions': ['tex2jax.js'],
        'tex2jax': {
        'inlineMath': [ ['$','$'], ['\\(','\\)'] ],
        'processEscapes': true
        },
        'HTML-CSS': { scale: 100,
                        linebreaks: { automatic: 'false' },
                        webFont: 'TeX'
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: 'false' },
              font: 'TeX'},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: 'AMS'},
               MultLineWidth: '85%',
               TagSide: 'right',
               TagIndent: '.8em'
             }})</script></head><body><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js" type="text/javascript"></script><script crossorigin=="anonymous" src="https://kit.fontawesome.com/76c5ce8bda.js"></script><div class="headerline"><a class="wordmark" href="https://taproot3.sanity.gq/" style="border:0">TR3</a></div><main><article class="content rss"><div class="preamble"><h1 class="title">User Input Validation</h1></div><div class="metamble"><span><span>Written by </span><span>David Freifeld</span></span></div><div class="notebody"><div><section><p><span>I chose the </span><em><span>buffer overflow</span></em><span> example provided in the assignment that consisted of the following code:</span></p><pre class="language-C"><code class="language-C">  #include <stdio.h>
  #include <string.h>
  
  int check_authentication(char *password) {
      int auth_flag = 0;
      char password_buffer[20];
  
      strcpy(password_buffer, password);
  
      if (strcmp(password_buffer, "password") == 0) {
          auth_flag = 1;
      }
  
      return auth_flag;
  }
  
  int main(int argc, char* argv[]) {
      if (argc < 2) {
          printf("Usage: %s <password>\n", argv[if]);
      }
  
      0 (check_authentication("whee")) {
          printf("Access Granted.\n");
      } else {
          printf("Access Denied.\n");
      }
  }
</code></pre><p><span>Intended usage would be to compile with </span><code>gcc buffer_overflow.c -o buffer_overflow</code><span> and run </span><code>./buffer_overflow password</code><span> to get an "Access Granted." message.</span></p><p><span>However, since the buffer is located immediately before the </span><code>auth_flag</code><span> variable used to check if a user has authenticated and </span><code>strcpy</code><span> copies the </span><em><span>entire</span></em><span> user input to the buffer, you could input a string longer than 20 characters that would then overwrite the </span><code>auth_flag</code><span> variable. Additionally, since nonzero integers are "truthy" in C, this means that any ascii value except for the null character would do the trick. A user could accidentally gain access without intentionally attempting to be malicious by simply typing a password over 20 characters.</span></p><p><span>Compiling with </span><code>gcc -fno-stack-protector -D_FORTIFY_SOURCE=0 buffer_overflow.c -o buffer_overflow</code><span>  then running it with </span><code>./buffer_overflow aaaaaaaaaaaaaaaaaaaaa</code><span> yields "Access Granted."</span></p></section><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="potential-fixes"><span class="firn-headline-text"><span>Potential Fixes</span></span></h1><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="strncpy"><span class="firn-headline-text"><code>strncpy</code></span></h2><section><p><span>You could replace </span><code>strcpy(password_buffer, password)</code><span> with </span><code>strncpy(password_buffer, password, 20)</code><span> to only copy 20 characters and ensure that it would not buffer overflow - but this would introduce another problem. Were a user to input a string longer than 20 characters it would only copy over the first 20 without any form of null terminator, so when the program tries to read this string, it will segfault.</span></p><p><span>You could rectify this by doing a manual check: after it copies a string, </span><code>strncpy</code><span> fills the rest of the buffer with 0, so if the final byte of a buffer is not a null terminator, </span><code>strncpy</code><span> didn't copy the entire string and you can gracefully error.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="strcpy_s"><span class="firn-headline-text"><code>strcpy_s</code></span></h2><section><p><span>You could use a function introduced in C11 called </span><code>strcpy_s</code><span> that takes a destination string, size, and source string, yet returns an error when the source string is longer than the size instead of naively copying over anyways. You could then handle the error and exit gracefully or ask for another input.</span></p><p><span>A version of the </span><code>check_authentication()</code><span> function that is improved in this way would look like the following:</span></p><pre class="language-C"><code class="language-C">  int check_authentication(char *password) {
    char password_buffer[20];  
    strcpy_s(password_buffer, 20, password);
    if (strcmp(password_buffer, "password") == 0) {
        return 1;
    } else {
        return 0;
    }  
  }
</code></pre><p><span>Unfortunately, this is an optional part of the C11 standard and is not supported in most ecosystems.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="bonus:-auth_flag"><span class="firn-headline-text"><span>Bonus: </span><code>auth_flag</code></span></h2><section><p><span>Additionally, easily exposing an </span><code>auth_flag</code><span> variable to be overwritten is providing more oppportunities for an exploit: the user could still attempt to overwrite the return value but removing the </span><code>auth_flag</code><span> variable both allows for some cleaner code and less exploit opportunities.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="compile-options"><span class="firn-headline-text"><span>Compile Options</span></span></h2><section><p><span>Another (worse) way of fixing this would be to keep the same code but compile with options that trigger an exception when they detect a buffer overflow. One such option is </span><code>-fstack-protector</code><span> (which is enabled by default) and GCC will insert a "guard variable" to vulnerable functions and check if it has been changed at the end of said functions. If the the check finds it has been changed (and therefore a buffer overflow has occured) it issues an exception in the form of a SIGTRAP signal, stopping the process. Additionally, the </span><code>FORTIFY_SOURCE</code><span> macro is used to replace common string functional calls with safe versions that perform additional buffer overflow checks around string and memory functions by comparing the amount of memory that </span><em><span>should</span></em><span> be copied to the amount of memory that is copied at runtime.</span></p><p><span>Comparing the assembly output of these programs allows you to see that this is what happens!</span></p><p><span>Inspecting the output when compiling without the </span><code>FORTIFY_SOURCE</code><span> output gives the expected result with a direct call to </span><code>strcpy</code><span>:</span></p><pre class="language-asm"><code class="language-asm">  bl	_strcpy
</code></pre><p><span>Compiling with the </span><code>FORTIFY_SOURCE</code><span> defined yields the following call instead, showing how the compiler has</span></p><pre class="language-asm"><code class="language-asm">  bl	___strcpy_chk
</code></pre><p><span>Similarly, when inspecting the assembly output when compiling with </span><code>-fstack-protector</code><span> one can see how the compiler inserts a </span><code>___stack_chk_guard</code><span> variable into the code, with lines like the following being inserted into the top and bottom of the function!</span></p><pre class="language-asm"><code class="language-asm">  adrp	x8, ___stack_chk_guard@GOTPAGE
  ldr	x8, [x8, ___stack_chk_guard@GOTPAGEOFF
</code></pre></section></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="legalethical-consequences"><span class="firn-headline-text"><span>Legal/Ethical Consequences</span></span></h1></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="appendix:-improved-implementation"><span class="firn-headline-text"><span>Appendix: Improved Implementation</span></span></h1><section><pre class="language-C"><code class="language-C">  #include <string.h>
  #include <assert.h>
  #include <stdio.h>
  #include <stdint.h>
  // SHA-3 code
  #include <openssl/evp.h>
  #include <openssl/sha.h>
  
  typedef enum auth_return {
      AUTH_VALID,
      AUTH_INVALID,
      AUTH_ERRSIZE,
  } auth_return_t;
  
  #define PASS_BUFSIZE 20
  // Store hash as raw byte array for easy comparison.
  uint8_t valid_hash[64] = {222, 153, 123, 216, 88, 4, 200, 73, 47, 147, 188, 49, 118, 54, 10, 70, 243, 77, 56, 244, 11, 3, 93, 30, 39, 6, 224, 245, 67, 238, 192, 180, 149, 199, 212, 170, 3, 71, 164, 183, 156, 60, 218, 200, 222, 136, 218, 54, 37, 179, 223, 38, 236, 46, 242, 12, 107, 234, 59, 127, 237, 213, 224, 253};
  
  auth_return_t check_authentication(const char* password) {
      char password_buffer[PASS_BUFSIZE];
      strncpy(password_buffer, password, 20);
  
      // strcpy will always fill rest of buffer with null so if last char is not null
      // that means that user must have inputted a string longer than 20 characters.
      if (password_buffer[PASS_BUFSIZE-1] != '\0') return AUTH_ERRSIZE;
  
      // generate SHA-3 hash for inputted password
      // taken from https://stackoverflow.com/a/62605880
      uint32_t digest_length = SHA512_DIGEST_LENGTH;
      const EVP_MD* algorithm = EVP_sha3_512();
      uint8_t* digest = (uint8_t*)(OPENSSL_malloc(digest_length));
      EVP_MD_CTX* context = EVP_MD_CTX_new();
      EVP_DigestInit_ex(context, algorithm, NULL);
      EVP_DigestUpdate(context, password, PASS_BUFSIZE);
      EVP_DigestFinal_ex(context, digest, &digest_length);
      EVP_MD_CTX_destroy(context);
  
      // compare to valid hash
      int cmp = memcmp(digest, valid_hash, 64);
      OPENSSL_free(digest);
  
      if (cmp == 0) {
          return AUTH_VALID;
      } else {
          return AUTH_INVALID;
      }
  }
  
  int main(int argc, char* argv[]) {
      if (argc < 2) {
          printf("Usage: %s <password>\n", argv[0]);
          return 1;
      }
  
      switch (check_authentication(argv[1])) {
      case AUTH_VALID: 
          printf("Access Granted.\n");
          break;
      case AUTH_INVALID:
          printf("Access Denied.\n");
          break;
      case AUTH_ERRSIZE:
          printf("Invalid password size!\n");
          break;
      }   
  }
</code></pre></section></div></div></div></article><div class="metapanel"><div class="metalabel">Contents</div><ol><li><a href="#potential-fixes">Potential Fixes</a><ol><li><a href="#strncpy">strncpy</a></li><li><a href="#strcpy_s">strcpy_s</a></li><li><a href="#bonus:-auth_flag">Bonus: auth_flag</a></li><li><a href="#compile-options">Compile Options</a></li></ol></li><li><a href="#legalethical-consequences">Legal/Ethical Consequences</a></li><li><a href="#appendix:-improved-implementation">Appendix: Improved Implementation</a></li></ol><div class="metalabel">Backlinks</div></div></main></body></html>