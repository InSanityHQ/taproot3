<html><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="Taproot Authors" name="author" /><meta content="A collection of academic and project notes" name="description" /><title>Taproot</title><link href="/static/css/firn_base.css" rel="stylesheet" /><link href="/static/css/prism.css" rel="stylesheet" /><link href="/static/css/global.css" rel="stylesheet" /><script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        'displayAlign': 'center',
        'displayIndent': '0em',
        'extensions': ['tex2jax.js'],
        'tex2jax': {
        'inlineMath': [ ['$','$'], ['\\(','\\)'] ],
        'processEscapes': true
        },
        'HTML-CSS': { scale: 100,
                        linebreaks: { automatic: 'false' },
                        webFont: 'TeX'
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: 'false' },
              font: 'TeX'},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: 'AMS'},
               MultLineWidth: '85%',
               TagSide: 'right',
               TagIndent: '.8em'}
tex: {
autoload: {
                cases: [[], ['numcases', 'subnumcases']]
        }
}})</script></head><body><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js" type="text/javascript"></script><div class="headerline"><a class="wordmark" href="https://taproot3.sanity.gq/" style="border:0">TR3</a></div><main><article class="content rss"><div class="preamble"><h1 class="title">User Input Validation Assignment</h1></div><div class="metamble"><span><span>Written by </span><span>Houjun Liu</span></span></div><div class="notebody"><div><section></section><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="clojure,-in-brief"><span class="firn-headline-text"><span>Clojure, in brief...</span></span></h1><section><p><span>The programming language </span><a class="firn-external" href="https://clojure.org/" target="_blank">Clojure</a><span>, a variant of Lisp built atop the Java Virtual Machine, is known to be a safe language to low level attacks such as buffer overflow due to the insulation of its execution space.</span></p><p><span>To preserve the functionality of being a Lisp, however, the Clojure preserves most of the powerful syntax-manipulation tools like unquote slicing and compile-time macros.</span></p><p><span>Before we could introduce the vulnerabilities that could come with the misuse of these tools, it is important to introduce these tools first.</span></p></section><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="unquote-slicing"><span class="firn-headline-text"><span>Unquote slicing</span></span></h2><section><p><span>"Unquoting" is a facility to introduce </span><code>code-mode</code><span> elements into </span><code>data-mode</code><span> lists. Here, for instance, is a regular data mode list that evaluates to value </span><code>(1 2 3 4)</code><span>:</span></p><pre class="language-clojure"><code class="language-clojure">'(1 2 3 4)
</code></pre><pre class="fixed-width"> (1 2 3 4)
</pre><p><span>Leveraging "unquoting", we could instead execute a </span><em><span>statement</span></em><span> that returns, for instance, </span><code>4</code><span> in place of the number </span><code>4</code><span> in the list instead of supplying the r-value </span><code>4</code><span> itself: therefore resulting in the same list but introducing live code during its parsing.</span></p><p><span>The syntax of unquoting is like so:</span></p><pre class="language-clojure"><code class="language-clojure">`(1 2 3 ~(* 2 2)) ; notice the ` instead of ' to denote a unquotable list
</code></pre><pre class="fixed-width"> (1 2 3 4)
</pre><p><span>As you could see, the result is still </span><code>(1 2 3 4)</code><span>, yet the latter case leveraged </span><code>(* 2 2); => 4</code><span> to </span><em><span>unquote</span></em><span> the value </span><code>4</code><span> into the list using live code.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="macros"><span class="firn-headline-text"><span>Macros</span></span></h2><section><p><span>Marcos are a powerful way of manipulating the syntax of code. Essentially, they are compile-time unraveled directives that take arguments as </span><code>data-mode</code><span> lists and return a sliced </span><code>data-mode</code><span> expression.</span></p><p><span>Here's a basic example of the functionality of Macros. Take, for instance, the following expression adding two numbers:</span></p><pre class="language-clojure"><code class="language-clojure">(+ 1 2)
</code></pre><pre class="fixed-width"> 3
</pre><p><span>We will now write a macro whose behavior is to reverse the order of the first two expressions before evaluating, like so:</span></p><pre class="language-clojure"><code class="language-clojure">(defmacro rev-arg [a b c]
    `(~b ~a ~c))
</code></pre><pre class="fixed-width"> #'user/rev-arg
</pre><p><span>Now, leveraging this macro, we could write the addition statement in an now admittedly weird manner:</span></p><pre class="language-clojure"><code class="language-clojure">(rev-arg 1 + 2)
</code></pre><pre class="fixed-width"> 3
</pre><p><span>As you could see, this macro did not </span><em><span>evaluate</span></em><span> its arguments, but instead took them as </span><code>data-mode</code><span> items and swapped their order. The return value of the macro is yet another </span><code>data-mode</code><span> list representing the unwrapped expression (now with the order corrected), which is finally evaluated on runtime.</span></p></section></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="dangers-of-macro-arguments"><span class="firn-headline-text"><span>Dangers of Macro Arguments</span></span></h1><section><p><span>Macros do not evaluate nor --- by default --- make any attempts to parse the contents of it arguments. Therefore, if an argument is unquoted wholesale into the result unwrapped expression, it is functionally equivalent to calling </span><code>eval</code><span> upon the statement is it will not be parsed at </span><em><span>compile-time</span></em><span> but instead on </span><em><span>run-time</span></em><span>.</span></p><p><span>Especially dangerous an action is if the argument of macros come from user input, as --- with functions --- the argument would either be passed consciously as fully data or evaluated with </span><code>eval</code><span> but is potentially sliced into the source tree and evaluated automatically on run-time for macros.</span></p><p><span>Here's the simplest example of runtime evaluation caused by a macro:</span></p><pre class="language-clojure"><code class="language-clojure">(defmacro secreteval [a]
    `(do
        (println "one")
        ~a))
</code></pre><pre class="fixed-width"> #'user/secreteval
</pre><p><span>And now, we call this macro to demonstrate the run-time eval.</span></p><pre class="language-clojure"><code class="language-clojure">(secreteval (println "two"))
</code></pre><pre class="fixed-width"> one
: two
</pre><p><span>The </span><code>stdout</code><span> result is printed in order of </span><code>one</code><span> </span><code>two</code><span>, meaning that, indeed, the execution of the argument </span><code>(println "two")</code><span> not only took place but took place </span><em><span>after</span></em><span> the execution of the first part of the macro.</span></p><p><span>Compare this to the following functionally almost-similar </span><em><span>function</span></em><span>:</span></p><pre class="language-clojure"><code class="language-clojure">(defn nosecreteval [a]
  (do
    (println "one")
    a))
</code></pre><pre class="fixed-width"> #'user/nosecreteval
</pre><p><span>And calling it with the same input...</span></p><pre class="language-clojure"><code class="language-clojure">(nosecreteval (println "two"))
</code></pre><pre class="fixed-width"> two
: one
</pre><p><span>As you could see, the argument is evaluated and passed evaluated </span><em><span>before</span></em><span> the execution of the macro (likely compiled away by the JVM) and, should user data be passed this was as </span><em><span>data</span></em><span>, will not be evaluated at all due to its persistent as a list.</span></p></section></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="preventing-macro-argument-evaluation"><span class="firn-headline-text"><span>Preventing Macro Argument Evaluation</span></span></h1><section><p><span>The simplest mechanism by which this type of evaluation could be prevented is via the use of assert statements or even list manipulation to establish basic assumptions regarding the argument.</span></p></section><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="nonexample"><span class="firn-headline-text"><span>Nonexample</span></span></h2><section><p><span>For instance, we write the following macro create a list of two elements.</span></p><pre class="language-clojure"><code class="language-clojure">(defmacro bad-concat [a]
    `(list 1 ~a))
</code></pre><pre class="fixed-width"> #'user/bad-concat
</pre><p><span>Calling it with some "normal" elements will act as you'd expect.</span></p><pre class="language-clojure"><code class="language-clojure">(bad-concat 12)
</code></pre><pre class="fixed-width"> (1 12)
</pre><p><span>However, you could introduce code execution by, for instance, passing an expression that produces a side effect.</span></p><pre class="language-clojure"><code class="language-clojure">(bad-concat (println "Code execution!"))
</code></pre><pre class="fixed-width"> Code execution!
</pre><p><span>As you could see, the statement </span><code>code execution</code><span> is </span><em><span>printed</span></em><span>, instead of all of </span><code>(println "aoenust")</code><span> being concatenated to the list to </span><code>1</code><span>, as the author of the program presumably desired.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="assert-based-solution"><span class="firn-headline-text"><code>assert</code><span> based solution</span></span></h2><section><p><span>One way to solve this is by asserting that the argument </span><code>a</code><span> is an </span><code>atom</code><span> --- meaning it does not contain </span><code>s-expressions</code><span> that could be accidentally evaluated. This would be implemented as follows:</span></p><pre class="language-clojure"><code class="language-clojure">(defmacro better-concat [a]
    (assert (not (list? a)))
    `(list 1 ~a))
</code></pre><pre class="fixed-width"> #'user/better-concat
</pre><p><span>The first example returns what one would expect:</span></p><pre class="language-clojure"><code class="language-clojure">(better-concat 12)
</code></pre><pre class="fixed-width"> (1 12)
</pre><p><span>And the statement with side-effects would, on </span><em><span>compile-time</span></em><span> throw an </span><code>AssertError</code><span>.</span></p><pre class="language-clojure"><code class="language-clojure">(better-concat (println "Code execution!"))
</code></pre><pre class="fixed-width"> class clojure.lang.Compiler$CompilerException
</pre></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="more-ergonomic-solution"><span class="firn-headline-text"><span>More ergonomic solution</span></span></h2><section><p><span>There is an even more ergonomic solution to this problem. Instead of validating input, we could coerce the input to </span><code>data-mode</code><span> using the quote-expression, essentially sanitizing it. Hence, we could create an even more ergonomic concat like so:</span></p><pre class="language-clojure"><code class="language-clojure">(defmacro ergo-concat [a]
    `(list 1 '~a))
</code></pre><pre class="fixed-width"> #'user/ergo-concat
</pre><p><span>The first example still remains the same:</span></p><pre class="language-clojure"><code class="language-clojure">(ergo-concat 12)
</code></pre><pre class="fixed-width"> (1 12)
</pre><p><span>and the side-effect statement will perform more ergonomically:</span></p><pre class="language-clojure"><code class="language-clojure">(ergo-concat (println "Code execution!"))
</code></pre><pre class="fixed-width"> (1 (println "Code execution!"))
</pre><p><span>As you could see, the list is actually, properly sliced in instead of triggering executing code.</span></p></section></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="legalethical-concerns"><span class="firn-headline-text"><span>Legal/Ethical Concerns</span></span></h1><section><p><span>The problem that exist with Clojure macro evaluation is that it is very easily (and perhaps commonly) created by even seasoned Clojurists. Acc</span></p></section></div></div></div></article><div class="metapanel"><div class="metalabel">Contents</div><ol><li><a href="#clojure,-in-brief">Clojure, in brief...</a><ol><li><a href="#unquote-slicing">Unquote slicing</a></li><li><a href="#macros">Macros</a></li></ol></li><li><a href="#dangers-of-macro-arguments">Dangers of Macro Arguments</a></li><li><a href="#preventing-macro-argument-evaluation">Preventing Macro Argument Evaluation</a><ol><li><a href="#nonexample">Nonexample</a></li><li><a href="#assert-based-solution">assert based solution</a></li><li><a href="#more-ergonomic-solution">More ergonomic solution</a></li></ol></li><li><a href="#legalethical-concerns">Legal/Ethical Concerns</a></li></ol><div class="metalabel">Backlinks</div><ul class="firn-backlinks"><li class="firn-backlink"><a href="/cs/computer_security/index">CS240 Master Index</a></li></ul></div></main></body></html>