<html><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="Albert H" name="author" /><meta content="A note on Taproot, a connected notes system." name="description" /><title>Story of Science: Computational Complexity Theory</title><link href="/static/css/firn_base.css" rel="stylesheet" /><link href="/static/css/prism.css" rel="stylesheet" /><link href="/static/css/global.css" rel="stylesheet" /><script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        'displayAlign': 'center',
        'displayIndent': '0em',
        'extensions': ['tex2jax.js'],
        'tex2jax': {
        'inlineMath': [ ['$','$'], ['\\(','\\)'] ],
        'processEscapes': true
        },
        'HTML-CSS': { scale: 100,
                        linebreaks: { automatic: 'false' },
                        webFont: 'TeX'
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: 'false' },
              font: 'TeX'},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: 'AMS'},
               MultLineWidth: '85%',
               TagSide: 'right',
               TagIndent: '.8em'
             }})</script></head><body><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js" type="text/javascript"></script><div class="headerline"><a class="wordmark" href="https://taproot3.sanity.gq/" style="border:0">TR3</a></div><main><article class="content rss"><div class="preamble"><h1 class="title">Story of Science: Computational Complexity Theory</h1></div><div class="metamble"><span><span>Written by </span><span>Albert H</span></span></div><div class="notebody"><div><section></section><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="sources"><span class="firn-headline-text"><span>sources</span></span></h1><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="gentle-introductions"><span class="firn-headline-text"><span>gentle introductions</span></span></h2><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="https:enwikipediaorgwikicomputational_complexity_theory"><span class="firn-headline-text"><span>https://en.wikipedia.org/wiki/Computational_complexity_theory</span></span></h3></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="https:complexityzoonetpetting_zoo"><span class="firn-headline-text"><span>https://complexityzoo.net/Petting_Zoo</span></span></h3></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="https:wwwsimonsfoundationorg20131213richard-karp"><span class="firn-headline-text"><span>https://www.simonsfoundation.org/2013/12/13/richard-karp/</span></span></h3></div></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="overview"><span class="firn-headline-text"><span>overview</span></span></h1><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="computational-complexity-theory-studies-how-&quot;difficult&quot;-a-problem-is"><span class="firn-headline-text"><span>computational complexity theory studies how "difficult" a problem is</span></span></h2><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="importantly,-not-how-&quot;good&quot;-an-algorithm-is-this-field-deals-with-all-algorithms-that-solve-a-given-problem"><span class="firn-headline-text"><span>importantly, not how "good" an algorithm is... this field deals with all algorithms that solve a given problem</span></span></h3></div></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="key-concepts"><span class="firn-headline-text"><span>key concepts</span></span></h2><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="types-of-problems"><span class="firn-headline-text"><span>types of problems</span></span></h3></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="turing-machines"><span class="firn-headline-text"><span>Turing machines</span></span></h3></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="reducibility"><span class="firn-headline-text"><span>reducibility</span></span></h3></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="complexity-classes"><span class="firn-headline-text"><span>complexity classes</span></span></h3></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="hierarchy"><span class="firn-headline-text"><span>hierarchy</span></span></h3></div></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="key-problems"><span class="firn-headline-text"><span>key problems</span></span></h2><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="p-vs-np"><span class="firn-headline-text"><span>P vs NP</span></span></h3></div></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="richard-karp-(the-actual-assignment)"><span class="firn-headline-text"><span>richard karp (the actual assignment)</span></span></h1><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="overview"><span class="firn-headline-text"><span>overview</span></span></h2><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="basically,-see-https:wwwsimonsfoundationorg20131213richard-karp"><span class="firn-headline-text"><span>basically, see https://www.simonsfoundation.org/2013/12/13/richard-karp/</span></span></h3></div></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="todo-storyboard-richard-karp-life"><span class="firn-headline-text"><span>TODO storyboard richard karp life</span></span></h2></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="vocab-and-definitions"><span class="firn-headline-text"><span>vocab and definitions</span></span><span class="firn-org-tags"><span><a class="firn-org-tag" href="/tags#def">def</a></span></span></h1><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="dtm,-deterministic-turing-machine"><span class="firn-headline-text"><span>DTM, deterministic Turing machine</span></span></h2><section><p><span>   A Turing machine with one infinite tape and a state function that has exactly one output for each (tape value, machine state) input. (Not a formal definition).</span></p></section></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="complexity-classes"><span class="firn-headline-text"><span>complexity classes</span></span></h1><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="p"><span class="firn-headline-text"><span>P</span></span></h2><section><p><span>   Problems that can be solved in polynomial time using a deterministic Turing machine (DTM). These problems are generally considered "tractable" by the Cobham-Edmonds thesis.</span></p><p><span>   In practice, problems with large-degree solutions usually have smaller-degree solutions discovered later, so the division between P and other problems 'has turned out to be somewhat "natural"'.</span></p><p><span>   Examples: { graph reachability (whether two nodes are in the same component), 2SAT (SCC :)), matrix multiplication }</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="np"><span class="firn-headline-text"><span>NP</span></span></h2><section><p><span>   Problems that can be checked "yes" in polynomial time. For example, graph isomorphism.</span></p></section><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="whats-up-with-conp?-checkin-&quot;no&quot;??"><span class="firn-headline-text"><span>whats up with coNP? checkin "no"??</span></span><span class="firn-org-tags"><span><a class="firn-org-tag" href="/tags#toexpand">toexpand</a></span></span></h3></div></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="np-complete"><span class="firn-headline-text"><span>NP-complete</span></span></h2><section><p><span>   Problems that are complete for NP, aka. problems in NP that all other NP problems can be reduced to in polynomial time. One example is CircuitSAT: any NP problem can be reduced to CircuitSAT and any problem that CircuitSAT can be reduced to is also NP-complete. Showing that CircuitSAT or any other NP-complete problem can be solved in polynomial time implies that P = NP.</span></p><p><span>   Examples: TSP, SAT</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="ph-(polynomial-hierarchy?)"><span class="firn-headline-text"><span>PH (polynomial hierarchy?)</span></span><span class="firn-org-tags"><span><a class="firn-org-tag" href="/tags#toexpand">toexpand</a></span></span></h2><section><p><span>   Defined as the union of a set of recursively defined classes... something? Something about P and NP and oracles about NP and coNP. This is the thing that would collapse, I guess. Eg, why people don't think Graph Isomorphism is NP-complete.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="pspace"><span class="firn-headline-text"><span>PSPACE</span></span></h2><section><p><span>   Restricts space instead of time. This class is very large, and includes the entirety of NP (brute force check all possible proofs) and also PP and P^{#P}, apparently.</span></p><p><span>   Notable PSPACE-complete examples: QBF (or QSAT), deciding the winner of eg. Go.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="exp"><span class="firn-headline-text"><span>EXP</span></span></h2><section><p><span>   run-time bounded by $2^{p(n)}$ where $p$ is a polynomial (ig). EXP is generally big enough: it contains PSPACE, the polynomial hierarchy (PH), and 'most problems we ever hope to attack'. Of course, there are bigger ones.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="ac^0,-nc^0,-nc"><span class="firn-headline-text"><span>AC^0, NC^0, NC</span></span></h2><section><p><span>   small classes that have to do with circuit complexity.. generally the represent problems that can be solved quickly with massive parallelism.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="l"><span class="firn-headline-text"><span>L</span></span></h2><section><p><span>   Logarithmic space (logarithmic spaces on the Turing machine tape). This is nice because space is usually limited. L is contained within P because something about deterministic Turing machines?.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="ppoly"><span class="firn-headline-text"><span>P/poly</span></span></h2><section><p><span>   polynomial time algorithms that solve a problem given an advice string which is at most polynomial in length and a function only of the input size. P/exp would make all problems trivial (provide a lookup table), but P/poly is actually interesting, ig. P/poly contains P, so $NP \notin P/poly$ would imply $P \neq NP$.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="bpp"><span class="firn-headline-text"><span>BPP</span></span></h2><section><p><span>   Randomized algorithms where the error rate is 'bounded by a constant'. Error rate could be improved by running the algorithm more times and taking a majority vote.</span></p><p><span>   AKS primality test made a previously randomized algorithm deterministic, which was a 'key example of derandomization'. People apparently think that P = BPP (and this is an important open problem).</span></p></section></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="flows"><span class="firn-headline-text"><span>flows</span></span></h1><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="wikipedia-computational-complexity-theory"><span class="firn-headline-text"><span>Wikipedia computational complexity theory</span></span></h2><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="computational-problems"><span class="firn-headline-text"><span>computational problems</span></span></h3><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="problem-instances"><span class="firn-headline-text"><span>problem instances</span></span></h4><section><p><span>	 A problem describes the problem. the actual "numbers" that describe a specific problem is called a problem instance. sorting a list is a problem, sorting </span><em><span>this</span></em><span> list is a problem instance.</span></p></section></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="representing-problem-instances"><span class="firn-headline-text"><span>representing problem instances</span></span></h4><section><p><span>	 formally strings of characters from alphabets. The input size is the length of the string. Different representations can be chosen but it should be trivial (fast) to convert from one to the other.</span></p></section></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="decision-problems-(most-basic-type)"><span class="firn-headline-text"><span>decision problems (most basic type)</span></span></h4><section><p><span>	 Generally, given an input, the output is either yes (accept) or no (reject). For example, deciding whether a graph is connected or not.</span></p></section><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="it-can-be-thought-of-as-a-&quot;formal-language&quot;"><span class="firn-headline-text"><span>it can be thought of as a "formal language"</span></span><span class="firn-org-tags"><span><a class="firn-org-tag" href="/tags#toexpand">toexpand</a></span></span></h5></div></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="function-problems"><span class="firn-headline-text"><span>function problems</span></span></h4><section><p><span>	 Very general: a function problem 'is a computational problem where a single output (of a total function) is expected for every input, but the output is more complex than that of a decision problem'. Basically calculate a non-binary function.</span></p><p><span>	 Examples: traveling salesman, integer factorization.</span></p><p><span>	 However, all function problems can be modeled as decision problems: For some function $f(*args) \to ans$, it can be modeled as the decision problem of whether $(*args, ans)$ is a valid output.</span></p></section><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="but-does-this-really-work?-how-can-a-decision-tm-be-used-to-compute-the-function-output-efficiently?"><span class="firn-headline-text"><span>but does this really work? how can a decision TM be used to compute the function output efficiently?</span></span><span class="firn-org-tags"><span><a class="firn-org-tag" href="/tags#toexpand">toexpand</a></span></span></h5></div></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="size-of-an-instance"><span class="firn-headline-text"><span>size of an instance</span></span></h4><section><p><span>	 Size is usually the length of the input. The complexity is a function of the input size, usually representing the worst case time or space (or any other complexity measure) required for any input size.</span></p></section></div></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="machine-models-and-complexity-measures"><span class="firn-headline-text"><span>machine models and complexity measures</span></span></h3><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="turing-machine"><span class="firn-headline-text"><span>Turing machine</span></span></h4><section><p><span>	 standard Turing machine stuff. its very general. Many types of turing machines (probabilistic, non-deterministic, quantum, etc) are used to define different complexity classes.</span></p></section></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="other-machine-models"><span class="firn-headline-text"><span>other machine models</span></span><span class="firn-org-tags"><span><a class="firn-org-tag" href="/tags#toexpand">toexpand</a></span></span></h4><section><p><span>	 Other non-standard Turing machines are used, but the idea is that they aren't actually any better, somehow?</span></p></section></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="complexity-measures"><span class="firn-headline-text"><span>Complexity Measures</span></span></h4><section><p><span>	 Usually time or space, but any complexity measure that satisfies Blum's complexity axioms can be used. Examples include: communication complexity, circuit complexity.</span></p><p><span>	 Also constant factors don't really matter. And its usually the worst case.</span></p><p><span>	 Importantly, complexity measures are also a function of the type of Turing machine used, since some Turing machines are better in some scenarios.</span></p></section><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="blums-complexity-axioms"><span class="firn-headline-text"><span>blums complexity axioms</span></span><span class="firn-org-tags"><span><a class="firn-org-tag" href="/tags#toexpand">toexpand</a></span></span></h5></div></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="bestworstaverage-case"><span class="firn-headline-text"><span>best/worst/average case</span></span></h4><section><p><span>	 We generally talk about worst case complexity, but some algorithms have good average-case which is good enough (eg. quicksort). Generally, best-case < average-case < amortized analysis < worst-case.</span></p></section></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="upper-and-lower-bounds-for-problems"><span class="firn-headline-text"><span>upper and lower bounds for problems</span></span></h4><section><p><span>	 Importantly, this is </span><strong><span>not an upper or lower bound for an algorithm</span></strong><span>. Instead, for problems in general, it's relatively easy to decide an upper bound (which is just the worst case complexity of any correct algorithm), but a lower bound is difficult (since it must involve algorithms that haven't been discovered yet).</span></p></section></div></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="complexity-classes"><span class="firn-headline-text"><span>complexity classes</span></span></h3><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="dependencies"><span class="firn-headline-text"><span>dependencies</span></span></h4><section><p><span>	 Complexity classes are a function of the following factors</span></p></section><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="problem-type"><span class="firn-headline-text"><span>problem type</span></span></h5><section><p><span>	  { decision, function, counting, optimization, promise, etc }</span></p></section></div><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="computation-model"><span class="firn-headline-text"><span>computation model</span></span></h5><section><p><span>	  { deterministic Turing machine, non-deterministic, Boolean circuits, quantum TM, monotone circuits, etc }</span></p></section></div><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="bounded-resources"><span class="firn-headline-text"><span>bounded resources</span></span></h5><section><p><span>	  { polynomial time, logarithmic space, constant depth }</span></p></section></div></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="an-example-definition"><span class="firn-headline-text"><span>an example definition</span></span></h4><section><blockquote><p><span>	 The set of decision problems solvable by a deterministic Turing machine within time f(n). (This complexity class is known as DTIME(f(n)).)</span></p></blockquote><p><span>	 However, using a concrete function $f(n)$ is often computational-model-dependent, but the Cobham-Edmonds thesis states that 'the time complexities in any two reasonable general models of computation are polynomial related.'</span></p><p><span>	 This suggests that all if we want to be machine-independent, all polynomial problems are roughly the same and belong in the same class: P (for decision problems) and FP (for function problems).</span></p></section><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="why-are-there-different-classes-if-decision-and-function-problems-are-the-same-ish?-dunno"><span class="firn-headline-text"><span>why are there different classes if decision and function problems are the same-ish? dunno</span></span><span class="firn-org-tags"><span><a class="firn-org-tag" href="/tags#toexpand">toexpand</a></span></span></h5></div></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="important-complexity-classes"><span class="firn-headline-text"><span>important complexity classes</span></span></h4><section><p><span>	 A nice list here but the complexity petting zoo is more friendly.</span></p></section></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="hierarchy-theorems"><span class="firn-headline-text"><span>Hierarchy theorems</span></span><span class="firn-org-tags"><span><a class="firn-org-tag" href="/tags#toexpand">toexpand</a></span></span></h4><section><p><span>	 We would like to establish a strict containment hierarchy within classes (but between different eg. polynomial functions). This does that, apparently?</span></p></section></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="reduction"><span class="firn-headline-text"><span>Reduction</span></span></h4><section><p><span>	 Many problems can be turned into other problems in their class, which provides an upper bound on the difficulty of the problem.</span></p><p><span>	 There are many types of reductions, but the most common type is the polynomial-time reduction which means the reduction takes polynomial time. If you take a non-polynomial reduction to turn a problem into a polynomial problem, then you haven't proven anything.</span></p></section><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="hardness-and-completeness"><span class="firn-headline-text"><span>hardness and completeness</span></span></h5><section><p><span>	  A problem $X$ is hard for a class $C$ if every problem in $C$ can be reduced to $X$. A problem $X$ is complete for $C$ if it is hard for $C$ it is in $C$. NP-complete problems are the "most difficult problems in NP" because other problems can be reduced to them.</span></p><p><span>	  Being able to reduce a hard problem to another problem shows that that other problem is just as hard, by contradiction. Similarly, being able to reduce a hard problem to a known easy one collapses the hierarchy.</span></p></section></div></div></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="important-open-problems"><span class="firn-headline-text"><span>important open problems</span></span></h3><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="p-vs-np"><span class="firn-headline-text"><span>P vs NP</span></span></h4><section><p><span>	 If any NP-complete problem can be reduced (polynomially) to a P problem, then many NP problems would be solvable in polynomial time. There are many NP problems that we would like to solve efficiently, so this would be a big deal.</span></p><p><span>	 In fact, many of the other 'important open problems' are important because they would show that $P \neq  NP$.</span></p></section></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="np-indeterminate-problems-(in-np-but-not-in-p-nor-np-complete)"><span class="firn-headline-text"><span>NP-indeterminate problems (in NP but not in P nor NP-complete)</span></span><span class="firn-org-tags"><span><a class="firn-org-tag" href="/tags#toexpand">toexpand</a></span></span></h4><section><p><span>	 some theorem shows that if P neq NP then there are NP-indeterminate problems. If we show that there are none, then that proves P = NP. Some unclassified problems (graph isomorphism problem, integer factorization problem) being NP-complete would 'collapse the polynomial hierarchy.' ?????</span></p></section></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="separations-between-other-complexity-classes"><span class="firn-headline-text"><span>separations between other complexity classes</span></span></h4><section><p><span>	 There are many classes that are improper subsets of each other. If any of those relations can be shown to be a proper subset, then classes on either side would be unequal. For example, many such relations exist between P and NP and showing that one of those relations is a proper subset relation would prove that P != NP. Or, proving that two classes (eg. P, PSPACE) are equal would squish all classes in between into one (in this case, showing that P = NP).</span></p></section></div></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="intractability"><span class="firn-headline-text"><span>Intractability</span></span></h3><section><p><span>	Meaning "not handleable". The Cobham-Edmonds thesis suggests that all polynomial problems are tractable. However, in the real world, specific numbers matter ($N^{15}$ is much worse than $0.0001^N$)</span></p></section></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="continuous-complexity-theory"><span class="firn-headline-text"><span>continuous complexity theory</span></span><span class="firn-org-tags"><span><a class="firn-org-tag" href="/tags#toexpand">toexpand</a></span></span></h3><section><p><span>	Something about continuous functions or analog logic.</span></p></section></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="history"><span class="firn-headline-text"><span>History</span></span></h3><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="many-foundations-laid,-eg-turing-machine-in-1936-which-allowed-for-analysis-of-various-algorithms"><span class="firn-headline-text"><span>Many foundations laid, eg. Turing machine in 1936 which allowed for analysis of various algorithms.</span></span></h4></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="first-systematic-study-attributed-to-juris-hartmanis-and-richard-e-stearns-in-&quot;on-the-computational-complexity-of-algorithms&quot;-(1965)"><span class="firn-headline-text"><span>First systematic study attributed to Juris Hartmanis and Richard E. Stearns in "On the Computational Complexity of Algorithms" (1965)</span></span></h4></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="edmonds-(cobham-edmonds-thesis)-suggests-polynomial-problems-are-&quot;good&quot;-(1965)"><span class="firn-headline-text"><span>Edmonds (Cobham-Edmonds thesis) suggests polynomial problems are "good" (1965)</span></span></h4></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="other-studies-of-problems-with-bounded-resources-in-the-previous-few-years"><span class="firn-headline-text"><span>other studies of problems with bounded resources in the previous few years</span></span></h4></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="blum-axioms-for-complexity-measures-(1967),-and-the-&quot;speed-up-theorem&quot;"><span class="firn-headline-text"><span>Blum axioms for complexity measures (1967), and the "speed-up theorem"</span></span></h4></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="1971-stephen-cook-and-leonid-levin-proved-existance-of-practically-relevant-np-complete-problems"><span class="firn-headline-text"><span>1971 Stephen Cook and Leonid Levin proved existance of practically relevant NP-complete problems</span></span></h4></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="richard-karp-(1972)-showed-21-relevant-and-np-complete-problems-(op)"><span class="firn-headline-text"><span>Richard Karp (1972) showed 21 relevant and NP-complete problems (op)</span></span></h4><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="oldest-of-four-children,-born-to-jewish-family-in-dorchester,-boston"><span class="firn-headline-text"><span>oldest of four children, born to jewish family in Dorchester, Boston</span></span></h5></div><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="mother-got-harvard-degree-at-age-57-and-father-wanted-to-go-on-to-medschool-after-harvard-but-became-a-math-teacher-bc-he-couldn&apos;t-afford-med-school"><span class="firn-headline-text"><span>mother got harvard degree at age 57 and father wanted to go on to medschool after Harvard but became a math teacher bc he couldn't afford med school</span></span></h5></div><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="went-to-harvard,-some-career-jumps,-mostly-cs-professor-at-uc-berkeley"><span class="firn-headline-text"><span>went to harvard, some career jumps, mostly CS professor at UC Berkeley</span></span></h5></div><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="leads-a-number-of-societies-and-organizations,-including-international-computer-science-institute,-simons-institute-for-the-theory-of-computing"><span class="firn-headline-text"><span>leads a number of societies and organizations, including International Computer Science Institute, Simons Institute for the Theory of Computing</span></span></h5></div><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="and-also-got-a-bunch-of-prizes-for-his-work-on-np-complete-problems"><span class="firn-headline-text"><span>and also got a bunch of prizes for his work on NP-complete problems</span></span></h5></div><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="edmonds-karp-algorithm-for-max-flow-with-jack-edmonds-1971"><span class="firn-headline-text"><span>Edmonds-Karp algorithm for max flow with Jack Edmonds 1971</span></span></h5></div><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="landmark-np-completeness-paper-in-1972"><span class="firn-headline-text"><span>landmark NP-completeness paper in 1972</span></span></h5><div class="firn-headline-section firn-headline-section-6"><h6 class="firn-headline firn-headline-6" id="showed-21-problems-that-sat-can-be-reduced-to"><span class="firn-headline-text"><span>showed 21 problems that SAT can be reduced to</span></span></h6></div><div class="firn-headline-section firn-headline-section-6"><h6 class="firn-headline firn-headline-6" id="a-nice-tree-of-reducibility-+-some-previous-work-mentioned-in-the-paper"><span class="firn-headline-text"><span>a nice tree of reducibility + some previous work mentioned in the paper</span></span></h6></div></div><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="1973-hopcroft-karp-algorithm-with-john-hopcroft-for-bipartite-graph-max-matchings"><span class="firn-headline-text"><span>1973 Hopcroft-karp algorithm with john hopcroft for bipartite graph max matchings</span></span></h5></div><div class="firn-headline-section firn-headline-section-5"><h5 class="firn-headline firn-headline-5" id="some-other-work-later-on"><span class="firn-headline-text"><span>some other work later on</span></span></h5><section></section></div></div></div></div></div></div></div></article><div class="metapanel"><div class="metalabel">Contents</div><ol><li><a href="#sources">sources</a><ol><li><a href="#gentle-introductions">gentle introductions</a><ol><li><a href="#https:enwikipediaorgwikicomputational_complexity_theory">https://en.wikipedia.org/wiki/Computational_complexity_theory</a></li><li><a href="#https:complexityzoonetpetting_zoo">https://complexityzoo.net/Petting_Zoo</a></li><li><a href="#https:wwwsimonsfoundationorg20131213richard-karp">https://www.simonsfoundation.org/2013/12/13/richard-karp/</a></li></ol></li></ol></li><li><a href="#overview">overview</a><ol><li><a href="#computational-complexity-theory-studies-how-&quot;difficult&quot;-a-problem-is">computational complexity theory studies how "difficult" a problem is</a><ol><li><a href="#importantly,-not-how-&quot;good&quot;-an-algorithm-is-this-field-deals-with-all-algorithms-that-solve-a-given-problem">importantly, not how "good" an algorithm is... this field deals with all algorithms that solve a given problem</a></li></ol></li><li><a href="#key-concepts">key concepts</a><ol><li><a href="#types-of-problems">types of problems</a></li><li><a href="#turing-machines">Turing machines</a></li><li><a href="#reducibility">reducibility</a></li><li><a href="#complexity-classes">complexity classes</a></li><li><a href="#hierarchy">hierarchy</a></li></ol></li><li><a href="#key-problems">key problems</a><ol><li><a href="#p-vs-np">P vs NP</a></li></ol></li></ol></li><li><a href="#richard-karp-(the-actual-assignment)">richard karp (the actual assignment)</a><ol><li><a href="#overview">overview</a><ol><li><a href="#basically,-see-https:wwwsimonsfoundationorg20131213richard-karp">basically, see https://www.simonsfoundation.org/2013/12/13/richard-karp/</a></li></ol></li><li><a href="#todo-storyboard-richard-karp-life">TODO storyboard richard karp life</a></li></ol></li><li><a href="#vocab-and-definitions">vocab and definitions</a><ol><li><a href="#dtm,-deterministic-turing-machine">DTM, deterministic Turing machine</a></li></ol></li><li><a href="#complexity-classes">complexity classes</a><ol><li><a href="#p">P</a></li><li><a href="#np">NP</a><ol><li><a href="#whats-up-with-conp?-checkin-&quot;no&quot;??">whats up with coNP? checkin "no"??</a></li></ol></li><li><a href="#np-complete">NP-complete</a></li><li><a href="#ph-(polynomial-hierarchy?)">PH (polynomial hierarchy?)</a></li><li><a href="#pspace">PSPACE</a></li><li><a href="#exp">EXP</a></li><li><a href="#ac^0,-nc^0,-nc">AC^0, NC^0, NC</a></li><li><a href="#l">L</a></li><li><a href="#ppoly">P/poly</a></li><li><a href="#bpp">BPP</a></li></ol></li><li><a href="#flows">flows</a><ol><li><a href="#wikipedia-computational-complexity-theory">Wikipedia computational complexity theory</a><ol><li><a href="#computational-problems">computational problems</a><ol><li><a href="#problem-instances">problem instances</a></li><li><a href="#representing-problem-instances">representing problem instances</a></li><li><a href="#decision-problems-(most-basic-type)">decision problems (most basic type)</a><ol><li><a href="#it-can-be-thought-of-as-a-&quot;formal-language&quot;">it can be thought of as a "formal language"</a></li></ol></li><li><a href="#function-problems">function problems</a><ol><li><a href="#but-does-this-really-work?-how-can-a-decision-tm-be-used-to-compute-the-function-output-efficiently?">but does this really work? how can a decision TM be used to compute the function output efficiently?</a></li></ol></li><li><a href="#size-of-an-instance">size of an instance</a></li></ol></li><li><a href="#machine-models-and-complexity-measures">machine models and complexity measures</a><ol><li><a href="#turing-machine">Turing machine</a></li><li><a href="#other-machine-models">other machine models</a></li><li><a href="#complexity-measures">Complexity Measures</a><ol><li><a href="#blums-complexity-axioms">blums complexity axioms</a></li></ol></li><li><a href="#bestworstaverage-case">best/worst/average case</a></li><li><a href="#upper-and-lower-bounds-for-problems">upper and lower bounds for problems</a></li></ol></li><li><a href="#complexity-classes">complexity classes</a><ol><li><a href="#dependencies">dependencies</a><ol><li><a href="#problem-type">problem type</a></li><li><a href="#computation-model">computation model</a></li><li><a href="#bounded-resources">bounded resources</a></li></ol></li><li><a href="#an-example-definition">an example definition</a><ol><li><a href="#why-are-there-different-classes-if-decision-and-function-problems-are-the-same-ish?-dunno">why are there different classes if decision and function problems are the same-ish? dunno</a></li></ol></li><li><a href="#important-complexity-classes">important complexity classes</a></li><li><a href="#hierarchy-theorems">Hierarchy theorems</a></li><li><a href="#reduction">Reduction</a><ol><li><a href="#hardness-and-completeness">hardness and completeness</a></li></ol></li></ol></li><li><a href="#important-open-problems">important open problems</a><ol><li><a href="#p-vs-np">P vs NP</a></li><li><a href="#np-indeterminate-problems-(in-np-but-not-in-p-nor-np-complete)">NP-indeterminate problems (in NP but not in P nor NP-complete)</a></li><li><a href="#separations-between-other-complexity-classes">separations between other complexity classes</a></li></ol></li><li><a href="#intractability">Intractability</a></li><li><a href="#continuous-complexity-theory">continuous complexity theory</a></li><li><a href="#history">History</a><ol><li><a href="#many-foundations-laid,-eg-turing-machine-in-1936-which-allowed-for-analysis-of-various-algorithms">Many foundations laid, eg. Turing machine in 1936 which allowed for analysis of various algorithms.</a></li><li><a href="#first-systematic-study-attributed-to-juris-hartmanis-and-richard-e-stearns-in-&quot;on-the-computational-complexity-of-algorithms&quot;-(1965)">First systematic study attributed to Juris Hartmanis and Richard E. Stearns in "On the Computational Complexity of Algorithms" (1965)</a></li><li><a href="#edmonds-(cobham-edmonds-thesis)-suggests-polynomial-problems-are-&quot;good&quot;-(1965)">Edmonds (Cobham-Edmonds thesis) suggests polynomial problems are "good" (1965)</a></li><li><a href="#other-studies-of-problems-with-bounded-resources-in-the-previous-few-years">other studies of problems with bounded resources in the previous few years</a></li><li><a href="#blum-axioms-for-complexity-measures-(1967),-and-the-&quot;speed-up-theorem&quot;">Blum axioms for complexity measures (1967), and the "speed-up theorem"</a></li><li><a href="#1971-stephen-cook-and-leonid-levin-proved-existance-of-practically-relevant-np-complete-problems">1971 Stephen Cook and Leonid Levin proved existance of practically relevant NP-complete problems</a></li><li><a href="#richard-karp-(1972)-showed-21-relevant-and-np-complete-problems-(op)">Richard Karp (1972) showed 21 relevant and NP-complete problems (op)</a><ol><li><a href="#oldest-of-four-children,-born-to-jewish-family-in-dorchester,-boston">oldest of four children, born to jewish family in Dorchester, Boston</a></li><li><a href="#mother-got-harvard-degree-at-age-57-and-father-wanted-to-go-on-to-medschool-after-harvard-but-became-a-math-teacher-bc-he-couldn&apos;t-afford-med-school">mother got harvard degree at age 57 and father wanted to go on to medschool after Harvard but became a math teacher bc he couldn't afford med school</a></li><li><a href="#went-to-harvard,-some-career-jumps,-mostly-cs-professor-at-uc-berkeley">went to harvard, some career jumps, mostly CS professor at UC Berkeley</a></li><li><a href="#leads-a-number-of-societies-and-organizations,-including-international-computer-science-institute,-simons-institute-for-the-theory-of-computing">leads a number of societies and organizations, including International Computer Science Institute, Simons Institute for the Theory of Computing</a></li><li><a href="#and-also-got-a-bunch-of-prizes-for-his-work-on-np-complete-problems">and also got a bunch of prizes for his work on NP-complete problems</a></li><li><a href="#edmonds-karp-algorithm-for-max-flow-with-jack-edmonds-1971">Edmonds-Karp algorithm for max flow with Jack Edmonds 1971</a></li><li><a href="#landmark-np-completeness-paper-in-1972">landmark NP-completeness paper in 1972</a><ol><li><a href="#showed-21-problems-that-sat-can-be-reduced-to">showed 21 problems that SAT can be reduced to</a></li><li><a href="#a-nice-tree-of-reducibility-+-some-previous-work-mentioned-in-the-paper">a nice tree of reducibility + some previous work mentioned in the paper</a></li></ol></li><li><a href="#1973-hopcroft-karp-algorithm-with-john-hopcroft-for-bipartite-graph-max-matchings">1973 Hopcroft-karp algorithm with john hopcroft for bipartite graph max matchings</a></li><li><a href="#some-other-work-later-on">some other work later on</a></li></ol></li></ol></li></ol></li></ol></li></ol><div class="metalabel">Backlinks</div></div></main></body></html>