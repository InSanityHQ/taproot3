<html><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="Huxley Marvit" name="author" /><meta content="A note on Taproot, a connected notes system." name="description" /><title>Functional Programming</title><link href="/static/css/firn_base.css" rel="stylesheet" /><link href="/static/css/prism.css" rel="stylesheet" /><link href="/static/css/global.css" rel="stylesheet" /><link href="/static/css/admonition.css" rel="stylesheet" /><script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        'displayAlign': 'center',
        'displayIndent': '0em',
        'extensions': ['tex2jax.js'],
        'tex2jax': {
        'inlineMath': [ ['$','$'], ['\\(','\\)'] ],
        'processEscapes': true
        },
        'HTML-CSS': { scale: 100,
                        linebreaks: { automatic: 'false' },
                        webFont: 'TeX'
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: 'false' },
              font: 'TeX'},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: 'AMS'},
               MultLineWidth: '85%',
               TagSide: 'right',
               TagIndent: '.8em'
             }})</script></head><body><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js" type="text/javascript"></script><script crossorigin=="anonymous" src="https://kit.fontawesome.com/76c5ce8bda.js"></script><div class="headerline"><a class="wordmark" href="https://taproot3.sanity.gq/" style="border:0">TR3</a></div><main><article class="content rss"><div class="preamble"><h1 class="title">Functional Programming</h1></div><div class="metamble"><span><span>Written by </span><span>Huxley Marvit</span></span></div><div class="notebody"><div><section><p><span>#flo #inclass #intersession</span></p><hr /></section><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="functional!-sml!"><span class="firn-headline-text"><span>Functional! SML!</span></span></h1><section><p><span>^ = append "hello world" is hello world in SML. ## but let's get to the
functions define functions like in mathematical notation: </span><code>fn x = x*3</code></p><p><span>functions are valid variables. inp func leads to oup func, but u can
call like </span><code>(func)(param)</code><span> </span><code>fn 0 => true | x => false</code></p><p><span>absolute value func: </span><code>fn x => if x ></code><span> 0 then x else ~1*x= (remember,
negative sign is ~) or, we can say </span><code>val abs = {above func}</code></p><p><span>we can also have tuple inputs, like </span><code>fn (x, y) => x</code><span>. all functions have
one input type and one output type</span></p><p><span>this is, a statically typed language!</span></p><p><span>renaming variables is shadowing! the old items still use the old value.</span></p><p><span>or 0 function</span></p><p><span>we can allow recursive with val r factorial function:</span></p><p><span>it's written in LATEX?? > average exacting spec in LaTeX fan vs average
UB enjoyer - @david</span></p><p><span>proven to be entirely type safe</span></p></section><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="types!"><span class="firn-headline-text"><span>types!</span></span></h2><section><p><span>all of our declarations are: - expression - val x = e - val rec x = e</span></p><p><span>but now we get... - type t = types - datatype t =..</span></p><p><span>pattern matching to extract data</span></p><p><span>omg..</span></p></section><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="recursive-data-types"><span class="firn-headline-text"><span>recursive data types</span></span></h3><section><p><code>of</code><span> is the name of the constructor from the data that it carries</span></p><p><span>product of a list</span></p></section></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="lists!-the-builtin-kind"><span class="firn-headline-text"><span>lists! the builtin kind</span></span></h3><section></section></div></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="curryin&apos;"><span class="firn-headline-text"><span>curryin'</span></span></h2><section><p><span>but really, it let's us define functions with other functions instead of
tuples, we have </span><strong><span>iterated function calling</span></strong></p><p><span>val rec filter : ('a -> bool) -> 'a list -> 'a list = fn</span></p><p><span>if statements are really</span></p><p><code>()</code><span> is the unit: the zero size of tuples</span></p><p><span>one thing in the type unit, as opposed to bool which has 2. this means
we already know what it will be! void really returns </span><code>()</code><span>, the unit</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="types!"><span class="firn-headline-text"><span>Types!</span></span></h2><section><p><span>what is a type?</span></p><p><span>first, </span><strong><span>groups</span></strong><span>. - a group has: - elements : types - an operator :
composition? forming tuples - identity : unit - what about inverse...?
and closed? - assosiative</span><a class="firn-internal" href="/corners/KBxGroupAndMatricesIntro">KBxGroupAndMatricesIntro</a><span></span><a class="firn-internal" href="/corners/mathematics/linear_algebra/index">mathematics/linear_algebra/index</a></p><ul><li><p><span>two groups are equivalent</span></p></li><li><p><a class="firn-internal" href="/corners/KBrefIsomorphicVectorSpace">KBrefIsomorphicVectorSpace</a><span> we
  can have isomorphic types!</span></p></li><li><p><span>prove with pair of invertible functions</span></p></li><li><p><strong><span>magnitude</span></strong><span>: the size of the unit type</span></p></li><li><p><span>note: * is composed, and x is 'times.'</span></p></li></ul><table><tr><td><span>type</span></td><td><span>size</span></td></tr><tr></tr><tr><td><span>unit</span></td><td><span>1</span></td></tr><tr><td><span>bool</span></td><td><span>2</span></td></tr><tr><td><span>a * b</span></td><td></td><td><span>a</span></td><td><span>x</span></td><td><span>b</span></td><td></td></tr><tr><td><span>unit * a</span></td><td></td><td><span>a</span></td><td></td></tr></table></section><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="rings"><span class="firn-headline-text"><span>Rings</span></span></h3><section><p><em><span>like groups, but extra.</span></em><span> two operations instead of one? we also need
assosiativity</span></p><p><span>note: 'a means alpha option = 'a, unit</span></p><table><tr><td><span>'a + option</span></td><td><span>= 1 +</span></td><td><span>a</span></td><td><span>=</span></td><td><span>'a</span></td><td><span>+</span></td><td><span>1</span></td><td><span>?</span></td></tr></table><p><span>the </span><code>+</code><span> op forms a datatype? </span><code>+</code><span> works on datatypes</span></p><p><span>adding in </span><code>+</code><span> to </span><code>x</code><span> means we get a </span><strong><span>semi-ring</span></strong></p><p><span>we cannot have something of (type, value)? </span><code>void</code><span> </span><code>void option</code><span> ~= to</span><code>()</code><span> note: ~= is isomorphic</span></p><p><span>\(|a \to b|\) is exponentiation, \(|b|^{|a|}\)</span></p></section></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="the-weirder-stuff"><span class="firn-headline-text"><span>the weirder stuff</span></span></h3><section><p><span>two things are isomprhic if you create a pair of functions that are
inverses</span></p><p><span>for example, </span><code>curry</code><span> and </span><code>uncurry</code><span>! forms an isomorphism between two
types we have proves that \((a^b)^c = a^{(b \cdot c)}\) with the
functions current and uncurry?? ????</span></p><p><span>this is a type theoretical proof.</span></p><blockquote><p><span>  "proofs and programs are actully one and the same" "types and
  propositions are also one and the same"</span></p></blockquote><p><span>the definition of a </span><strong><span>list</span></strong><span>: \(L(\alpha) = 1 + \alpha \times L(\alpha)\)
\(L(\alpha) = \alpha \times L(\alpha) = 1\)
\(L(\alpha) = \frac{1}{1-\alpha}=1+\alpha+\alpha^2+\alpha^3 \dots\)</span></p><p><span>wait wait wait WHAT? we just got the TAYLOR SERIES??</span><a class="firn-internal" href="/corners/KBhMATH401TaylorSeriesApprox">KBhMATH401TaylorSeriesApprox</a></p><p><span>\(\frac{d}{da} L(a) = \frac{d}{da} \frac{1}{1-a}\)</span></p><p><span>we can do DERIVATIVES?</span><a class="firn-internal" href="/corners/KBhMATH401Derivatives">KBhMATH401Derivatives</a><span> the derivative
of a list is.. two lists? a pair of lists?</span></p></section></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="the-structure-of-data"><span class="firn-headline-text"><span>the structure of data</span></span></h3><section><p><span>we can delete things. \(a^2\) , a data structure that holds two </span><code>a=s, we
have two ways to delete (rm either =a</code><span>) same is true for \(a+a\)</span></p><p><span>for \(a^3\), we have three things to choose from</span></p><p><span>the question is, what is left behind after something get's punched out?
\(a+a - a\) needs to maintain the same structure so \(a^2\) punched out</span><code>a</code><span> gives us \(a+\textrm{bool}\) so we know where the rmed </span><code>a</code><span> was. so
really, we have </span><code>a*option, a*option</code></p><p><span>wait, hole punching is a derivative?</span></p><p><span>\(a^2 => 2a\) essentially, just put a hole where the thing was removed</span></p><p><span>hence why, if we punch something out a linked list, we get two lists!
everything prior to the hole, and everything after the hole. and, since
we can get the element at the beginning and end of a list, we can get
the things around the hole instantly</span></p><p><span>we can move the hole, which means we can see in a vicinity and traverse,
like a directory structure!</span></p><p><span>we can define a tree as \(T(a)^2 \times L(a \times 2 \times T(a))\).
this fully defines a tree!</span></p><p><span>taking the second derivative means, we get two holes instead of one what
does this mean? i don't know!</span></p><p><span>done with type algebra, time for ## lambda calculus </span><em><span>istfg.</span></em><span> not actual
calculus. it just means, ways for operations to interact</span></p><p><span>church goes, how about, no, to turing. instead, let's use functions!</span></p><p><span>three constructs: - functions: fn x => exp - exp are exp(exp), x, fn -
\(\lambda x \cdot exp\)</span></p><p><span>\(\lambda x \cdot x\) is a simplex example function?</span></p></section><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="booleans"><span class="firn-headline-text"><span>booleans</span></span></h4><section><p><span>true is \(\lambda x \cdot \lambda y \cdot x\) false is
\(\lambda x \cdot \lambda y \cdot y\)</span></p><p><span>if a then b else c = abc which means, true bc => b and false bc => c</span></p></section></div><div class="firn-headline-section firn-headline-section-4"><h4 class="firn-headline firn-headline-4" id="numbers"><span class="firn-headline-text"><span>numbers</span></span></h4><section><p><span>the encoding of 1 =</span></p><p><span>\(\bar{0} = \lambda f . \lambda x . x\)\\
\(\bar{1} = \lambda f . \lambda x . fx\)\\
\(\bar{2} = \lambda f . \lambda x . f(fx)\)</span></p><p><span>now we define, incrementing! and, other stuff</span></p><p><span>\(\textrm{succ} = \lambda n . \lambda f . \lambda x . f(n(fx))\)
\(\textrm{add} = \lambda a . \lambda b . \lambda f . \lambda x . bf(afx)\)
\(\textrm{mult} = \lambda a . \lambda b . \lambda f . \lambda x . a(bf)x)\)</span></p><p><span>this is really, programming language theory. past function programming</span></p><p><span>the Y combinator actually comes from lambda calculus
\({\textsf {Y}}=\lambda f.\ (\lambda x.f\ (x\ x))\ (\lambda x.f\ (x\ x))\)</span></p></section></div></div></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="abstractions"><span class="firn-headline-text"><span>abstractions</span></span></h2><section><p><span>opaue types: types that we don't know the definition of we only know the
functions that can interact w/ them</span></p><p><span>exit functions can return void, because they exit anyways! we don't
care. -> technicaly, they are polymorphic</span></p><p><span>nvm, actully we are doing</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="finish-up-sml!"><span class="firn-headline-text"><span>finish up sml!</span></span></h2><section><p><span>can define using </span><code>deftype</code><span> and </span><code>type</code></p><p><span>we can represent using expression trees</span></p><p><span>and then we do this recursively until we get to our final result this is
evaluation! </span><strong><span>memory</span></strong><span> is linearly consumed with this unraveling instead,
if we pass down an accumulator, we can make this better</span></p><p><span>recursive call (ie. fact 3 4 -> fact (3-1) (4 * 3)) -> result -> fills
hole from above in accumulator then you pass the final value all the way
up</span></p><p><span>this actully </span><strong><span>doesnt help</span></strong><span>, but we can add an optimization which makes
it help</span></p></section><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="tailcall-optimization"><span class="firn-headline-text"><span>tailcall optimization</span></span></h3><section><blockquote><p><span>  Tail-call optimization is where you are able to avoid allocating a new
  stack frame for a function because the calling function will simply
  return the value that it gets from the called function. -stackoverflow
  (or not, ig, cus tailcall means we don't have it)</span></p></blockquote><p><span>-></span></p><p><span>this doesnt take up any extra space, because we dont need the previous
steps!</span></p><hr /><p><span>this means that k acts as out accumulator and, this has no backtracking,
as it is fully tailcall-optimized</span></p><p><span>this is dont by the compiler automatically to everything, which is why
we don't need a stack</span></p></section></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="an-example"><span class="firn-headline-text"><span>an example</span></span></h3><section><p><em><span>cps func</span></em><span> find1 : ('a -> bool) -> 'a shrub -> ('a -> 'z) -> (unit ->
'z') -> 'z</span></p><p><span>this is almost, imperative! once you are done being called, you are a
whole. the stack -> heap of clojures we get, one active line then heap
memory</span></p><p><span>when everything is tailcalls, that means we can get rid of functions and
instead just have </span><strong><span>continuations</span></strong><span> once you call something, you do not
exists. </span><code>oh_no()</code></p></section></div><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="continuations"><span class="firn-headline-text"><span>continuations</span></span></h3><section><p><span>we can define </span><code>letcc l => k</code><span> then, when we define k, we can quit out?</span></p><p><span>we can jump through time, with the old values? what??</span></p><p><span>let's "call for help" whenever we see a neg number</span></p><p><span>this let's us call k for help whenever we want we can invoke an entirely
different CONTROL FLOW, and then that returns the right thing in the
right type!</span></p><p><span>the call stack is still in mem, but when j becomes inaccessible, we
don't need need it anymore and it gets garbage collected!</span></p><blockquote><p><span>  proofs are programs and from programs you can extract a</span></p></blockquote></section></div></div></div></div></div></article><div class="metapanel"><div class="metalabel">Contents</div><ol><li><a href="#functional!-sml!">Functional! SML!</a><ol><li><a href="#types!">types!</a><ol><li><a href="#recursive-data-types">recursive data types</a></li><li><a href="#lists!-the-builtin-kind">lists! the builtin kind</a></li></ol></li><li><a href="#curryin&apos;">curryin'</a></li><li><a href="#types!">Types!</a><ol><li><a href="#rings">Rings</a></li><li><a href="#the-weirder-stuff">the weirder stuff</a></li><li><a href="#the-structure-of-data">the structure of data</a><ol><li><a href="#booleans">booleans</a></li><li><a href="#numbers">numbers</a></li></ol></li></ol></li><li><a href="#abstractions">abstractions</a></li><li><a href="#finish-up-sml!">finish up sml!</a><ol><li><a href="#tailcall-optimization">tailcall optimization</a></li><li><a href="#an-example">an example</a></li><li><a href="#continuations">continuations</a></li></ol></li></ol></li></ol><div class="metalabel">Backlinks</div><ul class="firn-backlinks"><li class="firn-backlink"><a href="/corners/KBIntersessionMasterIndex">Intersession Master Index</a></li></ul></div></main></body></html>