<html><head><meta charset="utf-8" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="Houjun Liu and Huxley Marvit" name="author" /><meta content="A note on Taproot, a connected notes system." name="description" /><title>Authorization Flow Design</title><link href="/static/css/firn_base.css" rel="stylesheet" /><link href="/static/css/prism.css" rel="stylesheet" /><link href="/static/css/global.css" rel="stylesheet" /><link href="/static/css/admonition.css" rel="stylesheet" /><script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        'displayAlign': 'center',
        'displayIndent': '0em',
        'extensions': ['tex2jax.js'],
        'tex2jax': {
        'inlineMath': [ ['$','$'], ['\\(','\\)'] ],
        'processEscapes': true
        },
        'HTML-CSS': { scale: 100,
                        linebreaks: { automatic: 'false' },
                        webFont: 'TeX'
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: 'false' },
              font: 'TeX'},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: 'AMS'},
               MultLineWidth: '85%',
               TagSide: 'right',
               TagIndent: '.8em'
             }})</script></head><body><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js" type="text/javascript"></script><script crossorigin=="anonymous" src="https://kit.fontawesome.com/76c5ce8bda.js"></script><div class="headerline"><a class="wordmark" href="https://taproot3.sanity.gq/" style="border:0">TR3</a></div><main><article class="content rss"><div class="preamble"><h1 class="title">Authorization Flow Design</h1></div><div class="metamble"><span><span>Written by </span><span>Houjun Liu and Huxley Marvit</span></span></div><div class="notebody"><div><section></section><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="understanding-authorization"><span class="firn-headline-text"><span>Understanding Authorization</span></span></h1><section><p><span>To be able to model and create intuitive and understandable authorization flows, one must understand the basis of authorization flows and the elements by which they are made successful.</span></p><p><span>In the most simply basis, authorization is the process by which permissions are assigned to a user. There are a few models by which authorization is done, and we will aim to list a few successful systems and their downfalls.</span></p><p><span>To begin this discussion, we will aim to describe a few terms:</span></p><ul><li><p><code>model</code><span>: a system of authentication, like the ones discussed below</span></p></li><li><p><code>agent</code><span>: the software tool in a </span><code>model</code><span> by which authorization is checked</span></p></li><li><p><code>rule</code><span>: a statement made available to the </span><code>agent</code><span> to validate claims made by </span><code>users</code></p></li><li><p><code>resource</code><span>: a file/page/tool by which the </span><code>model</code><span> aims to protect</span></p></li><li><p><code>action</code><span>: what the </span><code>agent</code><span> grants to do to a </span><code>resource</code></p></li><li><p><code>user</code><span>: an actor leveraging the </span><code>model</code><span>'s </span><code>agent</code><span> to gain perform </span><code>actions</code></p></li></ul></section><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="unixbsd-pam"><span class="firn-headline-text"><span>UNIX/BSD PAM</span></span></h2><section><p><span>The PAM authentications model, manifested in the </span><code>/etc/shadows</code><span> files on most *nix systems, is one of the most familiar system of authentication to most.</span></p><p><span>PAM protects individual resources by checking for an octal permission representing whether or not an </span><code>action</code><span> on a </span><code>resource</code><span> is accessible to a </span><code>user</code><span> or a group of users.</span></p><p><span>There exists 3 </span><code>actions</code><span>: read, write, and execute. The authorization </span><code>rules</code><span> are determined on a </span><code>resource</code><span> level, and </span><code>agents</code><span> check against </span><code>rules</code><span> on access time by users. User permissions override group permissions, which override global permissions.</span></p><p><span>This systems does not have permission dependencies nor exceptions, group grants and are the only batch executor available.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="afs"><span class="firn-headline-text"><span>AFS</span></span></h2><section><p><span>Access control lists first act separately upon directory resources and file resources. Hence, there are two groups of </span><code>actions</code><span> available: those that apply to directories and those that apply to files.</span></p><p><span>Apart from these permissions, groups/batch executors are applied via lookup and literal expressions-based batched execution by the </span><code>agent</code><span>. </span><code>rules</code><span>, like PAM, are singletons that only grant or remove specific </span><code>actions</code><span>.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="amazon-iam"><span class="firn-headline-text"><span>Amazon IAM</span></span></h2><section><p><span>Because IAM is the backbone of the Amazon AWS infrastructure, every single lockable AWS permission is considered an </span><code>action</code><span>. </span><code>actions</code><span> could be grouped into presents named "roles", and </span><code>rules</code><span> could either apply a role (batched </span><code>actions</code><span>) or a specific </span><code>action</code><span> to a group.</span></p><p><span>Inheritance, therefore, could be applied via the creation of groups, applying those permissions to groups, and editing the groups; to prevent conflicts</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="microsoft-graph-permissions"><span class="firn-headline-text"><span>Microsoft Graph Permissions</span></span></h2><section><p><span>Microsoft Graph Permissions grants grouped </span><code>actions</code><span> to specific users. Each </span><code>action</code><span> have any number (or no) dependencies; hence, when the </span><code>agent</code><span> applies any </span><code>action</code><span> in the group to a users, all of the dependents </span><code>action</code><span> is simultaneously applied.</span></p><p><span>Similar to PAM, permission groups could be binned and </span><code>rules</code><span> applied together. However, there are still no user-level dependency.</span></p></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="oauth"><span class="firn-headline-text"><span>OAuth</span></span></h2><section><p><span>The OAuth </span><code>model</code><span> allows for authorization of third party </span><code>resources</code><span> without the </span><code>users</code><span> credentials.</span></p><p><span>OAuth creates access tokens which are then passed to third party  </span><code>models</code><span> which use the access token to access </span><code>resources</code><span> hosted by the resource server.</span></p><p><span>These temporary access tokens then expire, allowing for a third party to be authenticated without ever giving it credentials and vise versa.</span></p><p><span>Because of the generalization and lack of </span><code>model</code><span> of OAuth, there is no hard restriction to permission inheritance</span></p></section></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="new-system-proposal"><span class="firn-headline-text"><span>New System Proposal</span></span></h1><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="compiled-features"><span class="firn-headline-text"><span>compiled features</span></span></h2><section><ul><li><p><span>PAM is simple!</span></p><ul><li><p><span>few </span><code>actions</code></p></li><li><p><span>groups -> arbitrary user level granularity</span></p></li></ul><ul><li><p><span>AFS</span></p><ul><li><p><span>Top down from </span><code>resources</code></p></li><li><p><code>resource</code><span> dependent </span><code>actions</code><span> // we dont have this!</span></p><ul><li><p><span>lack of redundant </span><code>actions</code><span>  // but, we do have this!</span></p></li></ul></li></ul></li></ul></li><li><p><span>IAM</span></p><ul><li><p><span> roles</span></p><ul><li><p><code>actions</code><span> are abstracted from entities they apply to</span></p></li></ul></li></ul></li><li><p><span>Microsoft Graphs</span></p><ul><li><p><code>actions</code><span> can have dependencies on other </span><code>actions</code></p><ul><li><p><span>simplicity -> ease of use</span></p></li></ul></li></ul><ul><li><p><span>OAuth</span></p><ul><li><p><code>actions</code><span> are arbitrary</span></p></li><li><p><span>authurization is arbitrary</span></p><ul><li><p><span>auth is abstracted, thus we can protect credentials</span></p></li></ul></li></ul></li></ul></li></ul></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="new"><span class="firn-headline-text"><span>New</span></span></h2><section><ul><li><p><span>from OAuth: LEGITIMIZE</span></p><ul><li><p><span>credential server</span></p></li><li><p><span>resource server</span></p></li><li><p><span>token access in third party</span></p></li></ul></li><li><p><span>tree structure of roles, where each node contains</span></p><ul><li><p><span>{ add, sub, connections }</span></p></li><li><p><span>given a user at a node, we DFS through the tree and append actions to a list</span></p></li></ul></li><li><p><span>user contains:</span></p><ul><li><p><span>n roles which generate a final action list (through dfs applied above)</span></p></li></ul></li><li><p><span>superuser gets root node</span></p></li></ul><p><span>[executer] -> [exucture]
[editor] -> [ [read], [write] ]</span></p></section></div></div></div></div></article><div class="metapanel"><div class="metalabel">Contents</div><ol><li><a href="#understanding-authorization">Understanding Authorization</a><ol><li><a href="#unixbsd-pam">UNIX/BSD PAM</a></li><li><a href="#afs">AFS</a></li><li><a href="#amazon-iam">Amazon IAM</a></li><li><a href="#microsoft-graph-permissions">Microsoft Graph Permissions</a></li><li><a href="#oauth">OAuth</a></li></ol></li><li><a href="#new-system-proposal">New System Proposal</a><ol><li><a href="#compiled-features">compiled features</a></li><li><a href="#new">New</a></li></ol></li></ol><div class="metalabel">Backlinks</div><ul class="firn-backlinks"><li class="firn-backlink"><a href="/cs/computer_security/index">CS240 Master Index</a></li></ul></div></main></body></html>